Alpine Expression Error: Unexpected end of input

Expression: "{ 
  previewData: [], 
  loading: false,
  currentPage: 1,
  totalPages: 1,
  totalCount: 0,
  searchQuery: '',
  async loadDataFromPouchDB(page = 1) {
    if (!card.config.dataSource) return;
    
    this.loading = true;
    const formId = card.config.dataSource;
    console.log('Loading data from PouchDB for form:', formId, 'page:', page);
    
    try {
      await initializePouchDB(formId);
      const pouchDB = new PouchDB(formId);
      
      // Use configured page size, default to 25 if not set
      const pageSize = parseInt(card.config.pageSize) || 25;
      const skip = (page - 1) * pageSize;
      console.log('Using page size:', pageSize, 'skip:', skip);
      
      // Build Mango query selector with predefined filters
      const selector = this.buildMangoSelector();
      console.log('Using Mango selector:', JSON.stringify(selector, null, 2));
      
      // Get filtered data using Mango query
      let allData = [];
      try {
        const result = await pouchDB.find({
          selector: selector
        });
        allData = result.docs.filter(doc => !doc._id.startsWith('_design/'));
        console.log('Loaded filtered data using Mango query:', allData.length, 'documents');
      } catch (findError) {
        console.log('Mango query failed, falling back to allDocs:', findError);
        // Fallback to allDocs if Mango query fails
        const result = await pouchDB.allDocs({ include_docs: true });
        const allDocs = result.rows.map(row => row.doc).filter(doc => !doc._id.startsWith('_design/'));
        // Apply filters in memory if Mango query failed
        allData = this.applyFiltersInMemory(allDocs);
        console.log('Loaded and filtered data using allDocs:', allData.length, 'documents');
      }
      
      // Set total count and pages
      this.totalCount = allData.length;
      this.totalPages = Math.ceil(this.totalCount / pageSize);
      this.currentPage = page;
      
      // Apply pagination in memory
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      this.previewData = allData.slice(startIndex, endIndex);
      
      console.log(`Displaying page ${page}/${this.totalPages}, showing ${this.previewData.length} of ${this.totalCount} documents`);
      
    } catch (error) {
      console.error('Failed to load preview data for form', formId, ':', error);
      this.previewData = [];
    } finally {
      this.loading = false;
    }
  },
  buildMangoSelector() {
    // Start with base selector to exclude design documents
    const selector = {
      '_id': { '$gt': null }
    };
    
    // Add search query if provided
    if (this.searchQuery && this.searchQuery.trim()) {
      const searchTerm = this.searchQuery.trim();
      const searchableColumns = (card.config.columns || []).filter(col => col.visible && col.key);
      
      if (searchableColumns.length > 0) {
        // Create OR condition for searching across all visible columns
        const searchConditions = searchableColumns.map(column => ({
          [column.key]: { '$regex': new RegExp(searchTerm, 'i') }
        }));
        
        selector['$or'] = searchConditions;
      }
    }
    
    // Add predefined filters from column configuration
    const columns = card.config.columns || [];
    
    for (const column of columns) {
      if (!column.enablePredefinedFilter) continue;
      
      const fieldName = column.key;
      const operator = column.filterOperator || 'equals';
      let value = column.filterValue;
      
      // For multi-select fields, use filterValues array
      if (column.filterValues && Array.isArray(column.filterValues) && column.filterValues.length > 0) {
        value = column.filterValues;
      }
      
      // Skip if no value provided (except for exists/not_exists/empty/not_empty)
      if (!value && !['exists', 'not_exists', 'empty', 'not_empty'].includes(operator)) continue;
      
      switch (operator) {
        case 'equals':
          selector[fieldName] = value;
          break;
        case 'not_equals':
          selector[fieldName] = { '$ne': value };
          break;
        case 'contains':
          selector[fieldName] = { '$regex': new RegExp(value, 'i') };
          break;
        case 'not_contains':
          selector[fieldName] = { '$not': { '$regex': new RegExp(value, 'i') } };
          break;
        case 'greater_than':
          selector[fieldName] = { '$gt': parseFloat(value) || value };
          break;
        case 'less_than':
          selector[fieldName] = { '$lt': parseFloat(value) || value };
          break;
        case 'greater_equal':
          selector[fieldName] = { '$gte': parseFloat(value) || value };
          break;
        case 'less_equal':
          selector[fieldName] = { '$lte': parseFloat(value) || value };
          break;
        case 'in':
          const inValues = Array.isArray(value) ? value : value.split(