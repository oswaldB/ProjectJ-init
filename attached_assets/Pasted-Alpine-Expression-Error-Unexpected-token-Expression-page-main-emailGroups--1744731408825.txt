Alpine Expression Error: Unexpected token ':'

Expression: "{ page: 'main', ...(
{
  emailGroups: [],
  selectedGroupEmails: [],
  escalation: {
    id: null,
    blocks: [{
      name: '',
      level: '',
      assetClass: '',
      site: {
        name: '',
        entities: [],
        locations: []
      },
      triggers: [{
      issueFamily: '',
      comparisonKey: '',
      operator: '',
      value: '',
      when: '',
      template: ''
    }]
  },
  templates: [],
  issuesFamilies: ['Valuation', 'Data Quality', 'System', 'Process', 'People'],
  keys: [],
  extractKeys(fields) {
    const keys = [];
    fields.forEach(field => {
      if (field.key) {
        keys.push(field.key);
      }
      // Check for nested questions in options
      if (field.options) {
        field.options.forEach(option => {
          if (option.questions) {
            option.questions.forEach(question => {
              if (question.key) {
                keys.push(question.key);
              }
            });
          }
        });
      }
    });
    return keys;
  },
  assets: ['Rates', 'FX', 'Credit', 'Equity', 'Commodity'],
  entities: ['Entity1', 'Entity2', 'Entity3'],
  locations: ['Location1', 'Location2', 'Location3'],
  sites: [],
  selectedDrawer: -1,
  selectedTriggerIndex: 0,
  showNewSiteModal: false,
  newSite: {
    id: null,
    name: '',
    form: '',
    status: 'draft',
    entities: [],
    locations: []
  },
  filter: '',
  async init() {
    const id = window.location.pathname.split('/').pop();
    if (id === 'new') {
      this.escalation.id = `escalation-${Date.now()}`;
    } else {
      await this.loadEscalation(id);
    }
    await this.loadTemplates();
    await this.loadSites();
    await this.loadForms();
    await this.loadEmailGroups();
  },
  async loadEmailGroups() {
    try {
      const response = await fetch('/api/sultan/emailgroups/list');
      this.emailGroups = await response.json();
    } catch (error) {
      console.error('Failed to load email groups:', error);
      this.emailGroups = [];
    }
  },
  async loadEmailGroupDetails(groupId) {
    if (!groupId) {
      this.selectedGroupEmails = [];
      return;
    }
    try {
      const response = await fetch(`/api/sultan/emailgroups/${groupId}`);
      const group = await response.json();
      this.selectedGroupEmails = group.emails || [];
      // Update the trigger email field with the group's emails
      const selectedTrigger = this.escalation.triggers.find(t => t.selectedGroup === groupId);
      if (selectedTrigger) {
        selectedTrigger.email = this.selectedGroupEmails.join(',');
      }
    } catch (error) {
      console.error('Failed to load email group details:', error);
      this.selectedGroupEmails = [];
    }
  },
  async loadForms() {
    try {
      const response = await fetch('/api/sultan/forms/list');
      this.forms = await response.json();
    } catch (error) {
      console.error('Failed to load forms:', error);
    }
  },
  async loadFormData(formId) {
    if (!formId) {
      this.issuesFamilies = [];
      this.assets = [];
      this.keys = [];
      return;
    }
    try {
      const response = await fetch(`/api/sultan/forms/${formId}`);
      const formData = await response.json();

      const issueFamilyField = formData.fields.find(f => f.key === 'issue-family');
      const assetClassField = formData.fields.find(f => f.key === 'asset-class');

      if (issueFamilyField && issueFamilyField.options) {
        this.issuesFamilies = issueFamilyField.options.map(opt => opt.name);
      }
      if (assetClassField && assetClassField.options) {
        this.assets = assetClassField.options.map(opt => opt.name);
      }

      // Extract all keys from form fields
      this.keys = this.extractKeys(formData.fields);
    } catch (error) {
      console.error('Failed to load form data:', error);
    }
  },
  saveEntitiesForNewSite(entity) {
    if (!this.newSite.entities) {
      this.newSite.entities = [];
    }
    const index = this.newSite.entities.indexOf(entity);
    if (index === -1) {
      this.newSite.entities.push(entity);
    } else {
      this.newSite.entities.splice(index, 1);
    }
  },
  saveLocationsForNewSite(location) {
    if (!this.newSite.locations) {
      this.newSite.locations = [];
    }
    const index = this.newSite.locations.indexOf(location);
    if (index === -1) {
      this.newSite.locations.push(location);
    } else {
      this.newSite.locations.splice(index, 1);
    }
  },
  async loadEscalation(id) {
    try {
      const response = await fetch(`/api/sultan/escalation/${id}`);
      this.escalation = await response.json();
    } catch (error) {
      console.error('Failed to load escalation:', error);
    }
  },
  async loadTemplates() {
    try {
      const response = await fetch('/api/sultan/templates/list');
      this.templates = await response.json();
    } catch (error) {
      console.error('Failed to load templates:', error);
    }
  },
  async createSite() {
    try {
      const response = await fetch('/api/sultan/sites/save', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({site: this.newSite})
      });
      if (response.ok) {
        this.showNewSiteModal = false;
        await this.loadSites();
      }
    } catch (error) {
      console.error('Failed to save site:', error);
    }
  },
  async loadSites() {
    try {
      const response = await fetch('/api/sultan/sites/list');
      const allSites = await response.json();
      this.sites = allSites.filter(site => site.status === 'prod');
    } catch (error) {
      console.error('Failed to load sites:', error);
      this.sites = [];
    }
  },
  async save() {
    try {
      const response = await fetch('/api/sultan/escalation/save', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({escalation: this.escalation})
      });
      if (response.ok) {
        window.location.href = '/sultan/escalation';
      }
    } catch (error) {
      console.error('Failed to save escalation:', error);
    }
  },
  saveEntities(entity) {
    if (!this.escalation.site.entities) {
      this.escalation.site.entities = [];
    }
    const index = this.escalation.site.entities.indexOf(entity);
    if (index === -1) {
      this.escalation.site.entities.push(entity);
    } else {
      this.escalation.site.entities.splice(index, 1);
    }
  },
  saveLocations(location) {
    if (!this.escalation.site.locations) {
      this.escalation.site.locations = [];
    }
    const index = this.escalation.site.locations.indexOf(location);
    if (index === -1) {
      this.escalation.site.locations.push(location);
    } else {
      this.escalation.site.locations.splice(index, 1);
    }
  },
  selectedTriggerIndex: 0,
  selectedTab: 'form',
  newEmail: '',
  newEmailGroup: '',
  showNewGroupModal: false,
  newGroupName: '',
  createEmailGroup() {
    const trigger = this.escalation.triggers[this.selectedTriggerIndex];
    if (!trigger) {
      alert('Please select a trigger first');
      return;
    }

    if (!trigger.emailList) {
      trigger.emailList = [];
    }

    if (trigger.emailList.length === 0) {
      alert('Please add some emails first');
      return;
    }

    this.newGroupName = '';
    this.showNewGroupModal = true;
  },
  saveNewEmailGroup() {
    const trigger = this.escalation.triggers[this.selectedTriggerIndex];
    if (!this.newGroupName) return;

    const newGroup = {
      id: `emailgroups-${Date.now()}`,
      name: this.newGroupName,
      description: 'Created from escalation',
      emails: trigger.emailList,
      status: 'draft'
    };

    fetch('/api/sultan/emailgroups/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ emailgroup: newGroup })
    })
    .then(response => {
      if (response.ok) {
        this.showNewGroupModal = false;
        this.loadEmailGroups();
      } else {
        throw new Error('Failed to create email group');
      }
    })
    .catch(error => {
      console.error('Error creating email group:', error);
      alert('Failed to create email group');
    });
  },
}
) }"

 <div class=​"min-h-screen flex" x-data=​"{ page:​ 'main', ...(
{
  emailGroups:​ []​,
  selectedGroupEmails:​ []​,
  escalation:​ {
    id:​ null,
    blocks:​ [{
      name:​ '',
      level:​ '',
      assetClass:​ '',
      site:​ {
        name:​ '',
        entities:​ []​,
        locations:​ []​
      }​,
      triggers:​ [{
      issueFamily:​ '',
      comparisonKey:​ '',
      operator:​ '',
      value:​ '',
      when:​ '',
      template:​ ''
    }​]​
  }​,
  templates:​ []​,
  issuesFamilies:​ ['Valuation', 'Data Quality', 'System', 'Process', 'People']​,
  keys:​ []​,
  extractKeys(fields)​ {
    const keys = []​;​
    fields.forEach(field => {
      if (field.key)​ {
        keys.push(field.key)​;​
      }​
      /​/​ Check for nested questions in options
      if (field.options)​ {
        field.options.forEach(option => {
          if (option.questions)​ {
            option.questions.forEach(question => {
              if (question.key)​ {
                keys.push(question.key)​;​
              }​
            }​)​;​
          }​
        }​)​;​
      }​
    }​)​;​
    return keys;​
  }​,
  assets:​ ['Rates', 'FX', 'Credit', 'Equity', 'Commodity']​,
  entities:​ ['Entity1', 'Entity2', 'Entity3']​,
  locations:​ ['Location1', 'Location2', 'Location3']​,
  sites:​ []​,
  selectedDrawer:​ -1,
  selectedTriggerIndex:​ 0,
  showNewSiteModal:​ false,
  newSite:​ {
    id:​ null,
    name:​ '',
    form:​ '',
    status:​ 'draft',
    entities:​ []​,
    locations:​ []​
  }​,
  filter:​ '',
  async init()​ {
    const id = window.location.pathname.split('/​')​.pop()​;​
    if (id === 'new')​ {
      this.escalation.id = `escalation-${Date.now()​}​`;​
    }​ else {
      await this.loadEscalation(id)​;​
    }​
    await this.loadTemplates()​;​
    await this.loadSites()​;​
    await this.loadForms()​;​
    await this.loadEmailGroups()​;​
  }​,
  async loadEmailGroups()​ {
    try {
      const response = await fetch('/​api/​sultan/​emailgroups/​list')​;​
      this.emailGroups = await response.json()​;​
    }​ catch (error)​ {
      console.error('Failed to load email groups:​', error)​;​
      this.emailGroups = []​;​
    }​
  }​,
  async loadEmailGroupDetails(groupId)​ {
    if (!groupId)​ {
      this.selectedGroupEmails = []​;​
      return;​
    }​
    try {
      const response = await fetch(`/​api/​sultan/​emailgroups/​${groupId}​`)​;​
      const group = await response.json()​;​
      this.selectedGroupEmails = group.emails || []​;​
      /​/​ Update the trigger email field with the group's emails
      const selectedTrigger = this.escalation.triggers.find(t => t.selectedGroup === groupId)​;​
      if (selectedTrigger)​ {
        selectedTrigger.email = this.selectedGroupEmails.join(',')​;​
      }​
    }​ catch (error)​ {
      console.error('Failed to load email group details:​', error)​;​
      this.selectedGroupEmails = []​;​
    }​
  }​,
  async loadForms()​ {
    try {
      const response = await fetch('/​api/​sultan/​forms/​list')​;​
      this.forms = await response.json()​;​
    }​ catch (error)​ {
      console.error('Failed to load forms:​', error)​;​
    }​
  }​,
  async loadFormData(formId)​ {
    if (!formId)​ {
      this.issuesFamilies = []​;​
      this.assets = []​;​
      this.keys = []​;​
      return;​
    }​
    try {
      const response = await fetch(`/​api/​sultan/​forms/​${formId}​`)​;​
      const formData = await response.json()​;​

      const issueFamilyField = formData.fields.find(f => f.key === 'issue-family')​;​
      const assetClassField = formData.fields.find(f => f.key === 'asset-class')​;​

      if (issueFamilyField && issueFamilyField.options)​ {
        this.issuesFamilies = issueFamilyField.options.map(opt => opt.name)​;​
      }​
      if (assetClassField && assetClassField.options)​ {
        this.assets = assetClassField.options.map(opt => opt.name)​;​
      }​

      /​/​ Extract all keys from form fields
      this.keys = this.extractKeys(formData.fields)​;​
    }​ catch (error)​ {
      console.error('Failed to load form data:​', error)​;​
    }​
  }​,
  saveEntitiesForNewSite(entity)​ {
    if (!this.newSite.entities)​ {
      this.newSite.entities = []​;​
    }​
    const index = this.newSite.entities.indexOf(entity)​;​
    if (index === -1)​ {
      this.newSite.entities.push(entity)​;​
    }​ else {
      this.newSite.entities.splice(index, 1)​;​
    }​
  }​,
  saveLocationsForNewSite(location)​ {
    if (!this.newSite.locations)​ {
      this.newSite.locations = []​;​
    }​
    const index = this.newSite.locations.indexOf(location)​;​
    if (index === -1)​ {
      this.newSite.locations.push(location)​;​
    }​ else {
      this.newSite.locations.splice(index, 1)​;​
    }​
  }​,
  async loadEscalation(id)​ {
    try {
      const response = await fetch(`/​api/​sultan/​escalation/​${id}​`)​;​
      this.escalation = await response.json()​;​
    }​ catch (error)​ {
      console.error('Failed to load escalation:​', error)​;​
    }​
  }​,
  async loadTemplates()​ {
    try {
      const response = await fetch('/​api/​sultan/​templates/​list')​;​
      this.templates = await response.json()​;​
    }​ catch (error)​ {
      console.error('Failed to load templates:​', error)​;​
    }​
  }​,
  async createSite()​ {
    try {
      const response = await fetch('/​api/​sultan/​sites/​save', {
        method:​ 'POST',
        headers:​ {'Content-Type':​ 'application/​json'}​,
        body:​ JSON.stringify({site:​ this.newSite}​)​
      }​)​;​
      if (response.ok)​ {
        this.showNewSiteModal = false;​
        await this.loadSites()​;​
      }​
    }​ catch (error)​ {
      console.error('Failed to save site:​', error)​;​
    }​
  }​,
  async loadSites()​ {
    try {
      const response = await fetch('/​api/​sultan/​sites/​list')​;​
      const allSites = await response.json()​;​
      this.sites = allSites.filter(site => site.status === 'prod')​;​
    }​ catch (error)​ {
      console.error('Failed to load sites:​', error)​;​
      this.sites = []​;​
    }​
  }​,
  async save()​ {
    try {
      const response = await fetch('/​api/​sultan/​escalation/​save', {
        method:​ 'POST',
        headers:​ {'Content-Type':​ 'application/​json'}​,
        body:​ JSON.stringify({escalation:​ this.escalation}​)​
      }​)​;​
      if (response.ok)​ {
        window.location.href = '/​sultan/​escalation';​
      }​
    }​ catch (error)​ {
      console.error('Failed to save escalation:​', error)​;​
    }​
  }​,
  saveEntities(entity)​ {
    if (!this.escalation.site.entities)​ {
      this.escalation.site.entities = []​;​
    }​
    const index = this.escalation.site.entities.indexOf(entity)​;​
    if (index === -1)​ {
      this.escalation.site.entities.push(entity)​;​
    }​ else {
      this.escalation.site.entities.splice(index, 1)​;​
    }​
  }​,
  saveLocations(location)​ {
    if (!this.escalation.site.locations)​ {
      this.escalation.site.locations = []​;​
    }​
    const index = this.escalation.site.locations.indexOf(location)​;​
    if (index === -1)​ {
      this.escalation.site.locations.push(location)​;​
    }​ else {
      this.escalation.site.locations.splice(index, 1)​;​
    }​
  }​,
  selectedTriggerIndex:​ 0,
  selectedTab:​ 'form',
  newEmail:​ '',
  newEmailGroup:​ '',
  showNewGroupModal:​ false,
  newGroupName:​ '',
  createEmailGroup()​ {
    const trigger = this.escalation.triggers[this.selectedTriggerIndex]​;​
    if (!trigger)​ {
      alert('Please select a trigger first')​;​
      return;​
    }​

    if (!trigger.emailList)​ {
      trigger.emailList = []​;​
    }​

    if (trigger.emailList.length === 0)​ {
      alert('Please add some emails first')​;​
      return;​
    }​

    this.newGroupName = '';​
    this.showNewGroupModal = true;​
  }​,
  saveNewEmailGroup()​ {
    const trigger = this.escalation.triggers[this.selectedTriggerIndex]​;​
    if (!this.newGroupName)​ return;​

    const newGroup = {
      id:​ `emailgroups-${Date.now()​}​`,
      name:​ this.newGroupName,
      description:​ 'Created from escalation',
      emails:​ trigger.emailList,
      status:​ 'draft'
    }​;​

    fetch('/​api/​sultan/​emailgroups/​save', {
      method:​ 'POST',
      headers:​ { 'Content-Type':​ 'application/​json' }​,
      body:​ JSON.stringify({ emailgroup:​ newGroup }​)​
    }​)​
    .then(response => {
      if (response.ok)​ {
        this.showNewGroupModal = false;​
        this.loadEmailGroups()​;​
      }​ else {
        throw new Error('Failed to create email group')​;​
      }​
    }​)​
    .catch(error => {
      console.error('Error creating email group:​', error)​;​
      alert('Failed to create email group')​;​
    }​)​;​
  }​,
}​
)​ }​">​…​</div>​flex
re @ cdn.min.js:1
(anonymous) @ cdn.min.js:5
jn @ cdn.min.js:5
Fn @ cdn.min.js:5
xt @ cdn.min.js:5
x @ cdn.min.js:5
R @ cdn.min.js:5
(anonymous) @ cdn.min.js:5
r @ cdn.min.js:5
n @ cdn.min.js:5
fr @ cdn.min.js:5
S @ cdn.min.js:5
(anonymous) @ cdn.min.js:5
gr @ cdn.min.js:5
(anonymous) @ cdn.min.js:5
cdn.min.js:1 Alpine Expression Error: escalation is not defined

Expression: "(escalation.blocks || [])"

 <template x-for=​"(block, blockIndex)​ in (escalation.blocks || []​)​" :key=​"blockIndex">​…​</template>​
re @ cdn.min.js:1
(anonymous) @ cdn.min.js:5
cdn.min.js:5 Uncaught SyntaxError: Unexpected token ':'