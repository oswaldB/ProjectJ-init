
{% extends "sultan/base.html" %}

{% block title %}Import HTML Form{% endblock %}

{% block content %}
<div class="p-6" x-data="{
  htmlContent: '',
  formName: '',
  extractedFields: [],
  isExtracting: false,
  
  init() {
    // Ensure component is properly initialized
    console.log('Import form component initialized');
  },
  
  async extractFields() {
    if (!this.htmlContent || !this.htmlContent.trim()) {
      alert('Please enter HTML content first');
      return;
    }
    
    this.isExtracting = true;
    this.extractedFields = [];
    
    try {
      // Create a temporary DOM element to parse HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = this.htmlContent || '';
      
      // Find all form elements
      const inputs = tempDiv.querySelectorAll('input, select, textarea');
      const fields = [];
      
      inputs.forEach((element, index) => {
        const field = {
          type: this.getFieldType(element),
          label: this.getFieldLabel(element, tempDiv),
          key: this.getFieldKey(element, index),
          required: element.hasAttribute('required'),
          options: [],
          description: '',
          open: true
        };
        
        // Handle select options
        if (element.tagName.toLowerCase() === 'select') {
          const options = element.querySelectorAll('option');
          options.forEach(option => {
            if (option.value && option.value !== '') {
              field.options.push({
                name: option.textContent.trim() || option.value,
                show: '',
                questions: []
              });
            }
          });
        }
        
        // Handle radio buttons and checkboxes
        if (element.type === 'radio' || element.type === 'checkbox') {
          const name = element.name;
          const existingField = fields.find(f => f.key === name);
          
          if (existingField) {
            // Add option to existing field
            existingField.options.push({
              name: element.value || element.id || `Option ${existingField.options.length + 1}`,
              show: '',
              questions: []
            });
          } else {
            // Create new field
            field.key = name || `field_${index}`;
            field.type = element.type === 'radio' ? 'single_select' : 'multiple_checkbox';
            field.options.push({
              name: element.value || element.id || 'Option 1',
              show: '',
              questions: []
            });
            fields.push(field);
          }
        } else {
          fields.push(field);
        }
      });
      
      this.extractedFields = fields;
    } catch (error) {
      console.error('Error extracting fields:', error);
      alert('Error extracting fields from HTML');
    } finally {
      this.isExtracting = false;
    }
  },
  
  getFieldType(element) {
    const tagName = element.tagName.toLowerCase();
    const type = element.type ? element.type.toLowerCase() : '';
    
    switch (tagName) {
      case 'textarea':
        return 'textarea';
      case 'select':
        return element.multiple ? 'multiple_checkbox' : 'single_select';
      case 'input':
        switch (type) {
          case 'text':
          case 'email':
          case 'tel':
          case 'url':
            return 'text';
          case 'number':
            return 'number';
          case 'date':
            return 'date';
          case 'file':
            return 'file_upload';
          case 'radio':
            return 'single_select';
          case 'checkbox':
            return 'multiple_checkbox';
          default:
            return 'text';
        }
      default:
        return 'text';
    }
  },
  
  getFieldLabel(element, container) {
    // Try to find label by for attribute
    const id = element.id;
    if (id) {
      const label = container.querySelector(`label[for="${id}"]`);
      if (label) {
        return label.textContent.trim();
      }
    }
    
    // Try to find label by wrapping
    const parentLabel = element.closest('label');
    if (parentLabel) {
      return parentLabel.textContent.replace(element.value || '', '').trim();
    }
    
    // Try to find nearby text
    const placeholder = element.placeholder;
    if (placeholder) {
      return placeholder;
    }
    
    // Use name or id as fallback
    return element.name || element.id || 'Untitled Field';
  },
  
  getFieldKey(element, index) {
    const name = element.name;
    const id = element.id;
    
    if (name) {
      return name.toLowerCase().replace(/[^a-z0-9]/g, '_');
    }
    
    if (id) {
      return id.toLowerCase().replace(/[^a-z0-9]/g, '_');
    }
    
    return `field_${index}`;
  },
  
  async createForm() {
    if (!this.formName.trim()) {
      alert('Please enter a form name');
      return;
    }
    
    if (this.extractedFields.length === 0) {
      alert('No fields extracted. Please extract fields first.');
      return;
    }
    
    const formData = {
      id: `forms-${Date.now()}`,
      name: this.formName,
      fields: this.extractedFields,
      status: 'Draft',
      last_modified: new Date().toISOString()
    };
    
    try {
      const response = await fetch('/pc-analytics-jaffar/sultan/api/forms/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ form: formData })
      });
      
      if (response.ok) {
        alert('Form created successfully!');
        window.location.href = `/pc-analytics-jaffar/sultan/forms/edit/${formData.id}`;
      } else {
        throw new Error('Failed to create form');
      }
    } catch (error) {
      console.error('Error creating form:', error);
      alert('Error creating form');
    }
  }
}">
  <div class="max-w-6xl mx-auto">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-white">Import HTML Form</h1>
      <a href="/pc-analytics-jaffar/sultan/forms" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700">
        Back to Forms
      </a>
    </div>
    
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- HTML Input Section -->
      <div class="bg-gray-800 p-6 rounded-lg">
        <h2 class="text-xl font-semibold text-white mb-4">HTML Content</h2>
        
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-2">Form Name</label>
            <input 
              type="text" 
              x-model="formName" 
              class="w-full bg-gray-700 text-white p-3 rounded border border-gray-600 focus:outline-none focus:border-blue-500"
              placeholder="Enter form name"
            >
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-2">HTML Content</label>
            <textarea 
              x-model="htmlContent"
              class="w-full bg-gray-700 text-white p-3 rounded border border-gray-600 focus:outline-none focus:border-blue-500 font-mono text-sm"
              rows="15"
              placeholder="Paste your HTML form content here..."
            ></textarea>
          </div>
          
          <button 
            @click="extractFields()"
            :disabled="isExtracting"
            class="w-full bg-blue-500 text-white py-3 px-4 rounded-lg hover:bg-blue-600 disabled:opacity-50"
          >
            <span x-show="!isExtracting">Extract Fields</span>
            <span x-show="isExtracting">Extracting...</span>
          </button>
        </div>
      </div>
      
      <!-- Extracted Fields Preview -->
      <div class="bg-gray-800 p-6 rounded-lg">
        <h2 class="text-xl font-semibold text-white mb-4">Extracted Fields</h2>
        
        <div x-show="extractedFields.length === 0" class="text-gray-400 text-center py-8">
          No fields extracted yet. Enter HTML content and click "Extract Fields".
        </div>
        
        <div x-show="extractedFields.length > 0" class="space-y-4">
          <div class="text-sm text-gray-300 mb-4">
            Found <span x-text="extractedFields.length"></span> fields
          </div>
          
          <div class="max-h-96 overflow-y-auto space-y-3">
            <template x-for="(field, index) in extractedFields" :key="index">
              <div class="bg-gray-700 p-3 rounded border border-gray-600">
                <div class="flex justify-between items-start">
                  <div class="flex-1">
                    <div class="font-medium text-white" x-text="field.label"></div>
                    <div class="text-sm text-gray-400">
                      Type: <span x-text="field.type"></span> | 
                      Key: <span x-text="field.key"></span>
                      <span x-show="field.required" class="text-red-400 ml-1">*</span>
                    </div>
                    <div x-show="field.options.length > 0" class="text-xs text-gray-500 mt-1">
                      Options: <span x-text="field.options.map(opt => opt.name).join(', ')"></span>
                    </div>
                  </div>
                </div>
              </div>
            </template>
          </div>
          
          <button 
            @click="createForm()"
            class="w-full bg-green-500 text-white py-3 px-4 rounded-lg hover:bg-green-600 mt-4"
          >
            Create Form
          </button>
        </div>
      </div>
    </div>
    
    <!-- Instructions -->
    <div class="mt-8 bg-gray-800 p-6 rounded-lg">
      <h3 class="text-lg font-semibold text-white mb-3">Instructions</h3>
      <div class="text-gray-300 space-y-2">
        <p>1. Enter a name for your form</p>
        <p>2. Paste your HTML form content in the text area</p>
        <p>3. Click "Extract Fields" to automatically detect form fields</p>
        <p>4. Review the extracted fields in the preview</p>
        <p>5. Click "Create Form" to generate the form</p>
      </div>
      
      <div class="mt-4 p-3 bg-blue-900 bg-opacity-50 rounded border border-blue-700">
        <p class="text-blue-300 text-sm">
          <strong>Supported elements:</strong> input (text, email, number, date, file, radio, checkbox), select, textarea
        </p>
      </div>
    </div>
  </div>
</div>
{% endblock %}
