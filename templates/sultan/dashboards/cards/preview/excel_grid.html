
<div class="bg-gray-800 p-4 rounded-lg h-full flex flex-col" x-data="{
  gridData: [],
  filteredData: [],
  sortColumn: null,
  sortDirection: 'asc',
  filters: {},
  selectedCells: [],
  loading: false,
  
  async init() {
    if (card.config.dataSource) {
      await this.loadGridData();
    }
  },
  
  async loadGridData() {
    this.loading = true;
    try {
      if (!card.config.dataSource) return;
      
      // Initialize PouchDB for the data source
      await this.initializePouchDB(card.config.dataSource);
      
      const db = new PouchDB(card.config.dataSource);
      const result = await db.allDocs({ include_docs: true });
      
      this.gridData = result.rows
        .map(row => row.doc)
        .filter(doc => !doc._id.startsWith('_design'))
        .filter(doc => doc.status !== 'draft');
      
      this.filteredData = [...this.gridData];
      
      // Apply row limit
      if (card.config.rowsToDisplay && card.config.rowsToDisplay !== 'all') {
        this.filteredData = this.filteredData.slice(0, parseInt(card.config.rowsToDisplay));
      }
      
    } catch (error) {
      console.error('Error loading grid data:', error);
    } finally {
      this.loading = false;
    }
  },
  
  async initializePouchDB(dataSource) {
    if (!dataSource) return;
    try {
      await window.initializePouchDB(dataSource);
    } catch (error) {
      console.error('Error initializing PouchDB for', dataSource, ':', error);
    }
  },
  
  sortColumn(columnKey) {
    if (this.sortColumn === columnKey) {
      this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      this.sortColumn = columnKey;
      this.sortDirection = 'asc';
    }
    
    this.filteredData.sort((a, b) => {
      const aVal = a[columnKey] || '';
      const bVal = b[columnKey] || '';
      
      if (this.sortDirection === 'asc') {
        return aVal > bVal ? 1 : -1;
      } else {
        return aVal < bVal ? 1 : -1;
      }
    });
  },
  
  filterColumn(columnKey, value) {
    if (value) {
      this.filters[columnKey] = value.toLowerCase();
    } else {
      delete this.filters[columnKey];
    }
    
    this.applyFilters();
  },
  
  applyFilters() {
    this.filteredData = this.gridData.filter(row => {
      return Object.keys(this.filters).every(key => {
        const cellValue = (row[key] || '').toString().toLowerCase();
        return cellValue.includes(this.filters[key]);
      });
    });
    
    // Apply row limit after filtering
    if (card.config.rowsToDisplay && card.config.rowsToDisplay !== 'all') {
      this.filteredData = this.filteredData.slice(0, parseInt(card.config.rowsToDisplay));
    }
  },
  
  formatCellValue(value, column) {
    if (!value && value !== 0) return '';
    
    switch (column.dataType) {
      case 'number':
        return Number(value).toLocaleString();
      case 'currency':
        return new Intl.NumberFormat('fr-FR', { style: 'currency', currency: 'EUR' }).format(value);
      case 'percentage':
        return (Number(value) * 100).toFixed(2) + '%';
      case 'date':
        return new Date(value).toLocaleDateString();
      case 'boolean':
        return value ? '✓' : '✗';
      default:
        return value;
    }
  },
  
  getCellStyle(value, column) {
    if (!column.conditionalFormatting) return {};
    
    let conditionMet = false;
    const numValue = Number(value);
    
    switch (column.formatCondition) {
      case 'greater':
        conditionMet = numValue > Number(column.formatValue);
        break;
      case 'less':
        conditionMet = numValue < Number(column.formatValue);
        break;
      case 'equal':
        conditionMet = value == column.formatValue;
        break;
      case 'contains':
        conditionMet = String(value).includes(column.formatValue);
        break;
    }
    
    if (conditionMet) {
      return {
        backgroundColor: column.formatBgColor || '#ffffff',
        color: column.formatTextColor || '#000000'
      };
    }
    
    return {};
  },
  
  exportToExcel() {
    try {
      const visibleColumns = (card.config.columns || []).filter(col => col.visible);
      const headers = visibleColumns.map(col => col.label);
      const rows = this.filteredData.map(row => 
        visibleColumns.map(col => this.formatCellValue(row[col.key], col))
      );
      
      const csvContent = [headers, ...rows]
        .map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(';'))
        .join('\n');
      
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `${card.config.title || 'excel_grid'}_${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Export failed:', error);
      alert('Export failed: ' + error.message);
    }
  }
}" x-init="init()">

  <!-- Header -->
  <div class="flex justify-between items-center mb-3 flex-shrink-0">
    <h3 class="text-white font-semibold text-sm" x-text="card.config.title || 'Excel Grid'"></h3>
    <div class="flex space-x-2">
      <button x-show="card.config.allowExportExcel" 
              @click="exportToExcel()" 
              class="bg-green-600 hover:bg-green-700 text-white px-2 py-1 rounded text-xs">
        Export
      </button>
      <button @click="loadGridData()" 
              class="bg-blue-600 hover:bg-blue-700 text-white px-2 py-1 rounded text-xs">
        Refresh
      </button>
    </div>
  </div>

  <!-- No data source -->
  <div x-show="!card.config.dataSource" class="bg-gray-700 p-4 rounded h-32 flex items-center justify-center">
    <span class="text-gray-400 text-sm">Select a data source to configure Excel grid</span>
  </div>

  <!-- Loading -->
  <div x-show="loading && card.config.dataSource" class="bg-gray-700 p-4 rounded h-32 flex items-center justify-center">
    <span class="text-gray-400 text-sm">Loading grid data...</span>
  </div>

  <!-- Excel Grid -->
  <div x-show="card.config.dataSource && !loading" class="flex-1 overflow-auto border border-gray-600 rounded">
    <div class="min-w-full bg-gray-900">
      <!-- Header Row -->
      <div class="flex bg-gray-700 border-b border-gray-600" 
           x-bind:class="{ 'sticky top-0': card.config.freezeFirstRow }">
        
        <!-- Row number header -->
        <div x-show="card.config.showRowNumbers" 
             class="w-12 px-2 py-2 border-r border-gray-600 text-center text-xs font-medium text-gray-300 bg-gray-800">
          #
        </div>
        
        <!-- Column headers -->
        <template x-for="column in (card.config.columns || []).filter(col => col.visible)" :key="column.key">
          <div class="border-r border-gray-600 bg-gray-700 flex flex-col"
               x-bind:style="{ width: (column.width || card.config.defaultCellWidth || 120) + 'px' }">
            
            <!-- Column title and sort -->
            <div class="px-2 py-2 flex items-center justify-between">
              <span class="text-xs font-medium text-white truncate" x-text="column.label"></span>
              <button x-show="card.config.allowSort" 
                      @click="sortColumn(column.key)"
                      class="text-gray-400 hover:text-white ml-1">
                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M5 8l5-5 5 5H5zm0 4h10l-5 5-5-5z"/>
                </svg>
              </button>
            </div>
            
            <!-- Column filter -->
            <div x-show="card.config.allowFilter" class="px-2 pb-2">
              <input type="text" 
                     @input="filterColumn(column.key, $event.target.value)"
                     class="w-full bg-gray-600 text-white text-xs p-1 rounded border border-gray-500"
                     placeholder="Filter...">
            </div>
          </div>
        </template>
      </div>

      <!-- Data rows -->
      <template x-for="(row, rowIndex) in filteredData" :key="row._id || rowIndex">
        <div class="flex border-b border-gray-600 hover:bg-gray-750">
          
          <!-- Row number -->
          <div x-show="card.config.showRowNumbers" 
               class="w-12 px-2 py-2 border-r border-gray-600 text-center text-xs text-gray-400 bg-gray-800">
            <span x-text="rowIndex + 1"></span>
          </div>
          
          <!-- Data cells -->
          <template x-for="column in (card.config.columns || []).filter(col => col.visible)" :key="column.key">
            <div class="border-r border-gray-600 px-2 py-2 text-xs"
                 x-bind:style="{ 
                   width: (column.width || card.config.defaultCellWidth || 120) + 'px',
                   ...getCellStyle(row[column.key], column)
                 }">
              
              <!-- Editable cell -->
              <div x-show="card.config.allowEdit && column.editable" 
                   class="h-full">
                <input type="text" 
                       x-bind:value="formatCellValue(row[column.key], column)"
                       class="w-full bg-transparent text-white border-none outline-none focus:bg-gray-600 focus:rounded px-1"
                       @blur="row[column.key] = $event.target.value">
              </div>
              
              <!-- Read-only cell -->
              <div x-show="!card.config.allowEdit || !column.editable" 
                   class="truncate text-white"
                   x-text="formatCellValue(row[column.key], column)">
              </div>
            </div>
          </template>
        </div>
      </template>
      
      <!-- Empty state -->
      <div x-show="filteredData.length === 0 && !loading" 
           class="text-center py-8 text-gray-400 text-sm">
        No data available
      </div>
    </div>
  </div>

  <!-- Footer info -->
  <div class="mt-2 text-xs text-gray-400 flex justify-between items-center flex-shrink-0">
    <span x-text="`Showing ${filteredData.length} rows`"></span>
    <span x-show="Object.keys(filters).length > 0" 
          class="text-blue-400"
          x-text="`${Object.keys(filters).length} filter(s) applied`">
    </span>
  </div>
</div>
