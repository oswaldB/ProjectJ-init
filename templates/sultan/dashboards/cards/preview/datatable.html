<div class="bg-gray-800 p-4 rounded-lg h-full" x-data="{
  previewData: [], 
  loading: false,
  currentPage: 1,
  totalPages: 1,
  totalCount: 0,
  searchQuery: '',
  async loadDataFromPouchDB(page = 1) {
    if (!card.config.dataSource) return;

    this.loading = true;
    const formId = card.config.dataSource;

    try {
      await initializePouchDB(formId);
      const pouchDB = new PouchDB(formId);

      // Use configured page size, default to 25 if not set
      const pageSize = parseInt(card.config.pageSize) || 25;
      const skip = (page - 1) * pageSize;

      // Build Mango query selector with predefined filters
      const selector = this.buildMangoSelector();

      // Get filtered data using Mango query
      let allData = [];
      try {
        const result = await pouchDB.find({
          selector: selector
        });
        allData = result.docs.filter(doc => !doc._id.startsWith('_design/'));
      } catch (findError) {
        // Fallback to allDocs if Mango query fails
        const result = await pouchDB.allDocs({ include_docs: true });
        const allDocs = result.rows.map(row => row.doc).filter(doc => !doc._id.startsWith('_design/'));
        // Apply filters in memory if Mango query failed
        allData = this.applyFiltersInMemory(allDocs);
      }

      // Set total count and pages
      this.totalCount = allData.length;
      this.totalPages = Math.ceil(this.totalCount / pageSize);
      this.currentPage = page;

      // Apply pagination in memory
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      this.previewData = allData.slice(startIndex, endIndex);

      console.log(`Displaying page ${page}/${this.totalPages}, showing ${this.previewData.length} of ${this.totalCount} documents`);

    } catch (error) {
      console.error('Failed to load preview data for form', formId, ':', error);
      this.previewData = [];
    } finally {
      this.loading = false;
    }
  },
  buildMangoSelector() {
    // Start with base selector to exclude design documents
    const selector = {
      '_id': { '$gt': null }
    };

    // Add search query if provided
    if (this.searchQuery && this.searchQuery.trim()) {
      const searchTerm = this.searchQuery.trim();
      const searchableColumns = (card.config.columns || []).filter(col => col.visible && col.key);

      if (searchableColumns.length > 0) {
        // Create OR condition for searching across all visible columns
        const searchConditions = searchableColumns.map(column => ({
          [column.key]: { '$regex': new RegExp(searchTerm, 'i') }
        }));

        selector['$or'] = searchConditions;
      }
    }

    // Add predefined filters from column configuration
    const columns = card.config.columns || [];

    for (const column of columns) {
      if (!column.enablePredefinedFilter) continue;

      const fieldName = column.key;
      const operator = column.filterOperator || 'equals';
      let value = column.filterValue;

      // For multi-select fields, use filterValues array
      if (column.filterValues && Array.isArray(column.filterValues) && column.filterValues.length > 0) {
        value = column.filterValues;
      }

      // Skip if no value provided (except for exists/not_exists/empty/not_empty)
      if (!value && !['exists', 'not_exists', 'empty', 'not_empty'].includes(operator)) continue;

      switch (operator) {
        case 'equals':
          selector[fieldName] = value;
          break;
        case 'not_equals':
          selector[fieldName] = { '$ne': value };
          break;
        case 'contains':
          selector[fieldName] = { '$regex': new RegExp(value, 'i') };
          break;
        case 'not_contains':
          selector[fieldName] = { '$not': { '$regex': new RegExp(value, 'i') } };
          break;
        case 'greater_than':
          selector[fieldName] = { '$gt': parseFloat(value) || value };
          break;
        case 'less_than':
          selector[fieldName] = { '$lt': parseFloat(value) || value };
          break;
        case 'greater_equal':
          selector[fieldName] = { '$gte': parseFloat(value) || value };
          break;
        case 'less_equal':
          selector[fieldName] = { '$lte': parseFloat(value) || value };
          break;
        case 'in':
          const inValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
          selector[fieldName] = { '$in': inValues };
          break;
        case 'not_in':
          const notInValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
          selector[fieldName] = { '$nin': notInValues };
          break;
        case 'exists':
          selector[fieldName] = { '$exists': true };
          break;
        case 'not_exists':
          selector[fieldName] = { '$exists': false };
          break;
        case 'empty':
          selector[fieldName] = { '$in': [null, '', undefined] };
          break;
        case 'not_empty':
          selector[fieldName] = { '$nin': [null, '', undefined] };
          break;
        case 'starts_with':
          selector[fieldName] = { '$regex': new RegExp(`^${value}`, 'i') };
          break;
        case 'ends_with':
          selector[fieldName] = { '$regex': new RegExp(`${value}$`, 'i') };
          break;
      }
    }

    return selector;
  },
  applyFiltersInMemory(docs) {
    // Fallback method to apply filters in memory when Mango queries fail
    let filteredDocs = docs;

    // Apply search filter first
    if (this.searchQuery && this.searchQuery.trim()) {
      const searchTerm = this.searchQuery.trim().toLowerCase();
      const searchableColumns = (card.config.columns || []).filter(col => col.visible && col.key);

      filteredDocs = filteredDocs.filter(doc => {
        return searchableColumns.some(column => {
          const value = doc[column.key];
          if (value === null || value === undefined) return false;
          return String(value).toLowerCase().includes(searchTerm);
        });
      });
    }

    // Apply predefined filters
    const columns = card.config.columns || [];

    return filteredDocs.filter(doc => {
      for (const column of columns) {
        if (!column.enablePredefinedFilter) continue;

        const fieldName = column.key;
        const operator = column.filterOperator || 'equals';
        let value = column.filterValue;

        // For multi-select fields, use filterValues array
        if (column.filterValues && Array.isArray(column.filterValues) && column.filterValues.length > 0) {
          value = column.filterValues;
        }

        // Skip if no value provided (except for exists/not_exists/empty/not_empty)
        if (!value && !['exists', 'not_exists', 'empty', 'not_empty'].includes(operator)) continue;

        const docValue = doc[fieldName];

        switch (operator) {
          case 'equals':
            if (docValue != value) return false;
            break;
          case 'not_equals':
            if (docValue == value) return false;
            break;
          case 'contains':
            if (!String(docValue || '').toLowerCase().includes(String(value || '').toLowerCase())) return false;
            break;
          case 'not_contains':
            if (String(docValue || '').toLowerCase().includes(String(value || '').toLowerCase())) return false;
            break;
          case 'greater_than':
            if (!(parseFloat(docValue) > parseFloat(value))) return false;
            break;
          case 'less_than':
            if (!(parseFloat(docValue) < parseFloat(value))) return false;
            break;
          case 'greater_equal':
            if (!(parseFloat(docValue) >= parseFloat(value))) return false;
            break;
          case 'less_equal':
            if (!(parseFloat(docValue) <= parseFloat(value))) return false;
            break;
          case 'in':
            const inValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
            if (!inValues.includes(String(docValue))) return false;
            break;
          case 'not_in':
            const notInValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
            if (notInValues.includes(String(docValue))) return false;
            break;
          case 'exists':
            if (docValue === null || docValue === undefined) return false;
            break;
          case 'not_exists':
            if (docValue !== null && docValue !== undefined) return false;
            break;
          case 'empty':
            if (docValue !== null && docValue !== undefined && docValue !== '') return false;
            break;
          case 'not_empty':
            if (docValue === null || docValue === undefined || docValue === '') return false;
            break;
          case 'starts_with':
            if (!String(docValue || '').toLowerCase().startsWith(String(value || '').toLowerCase())) return false;
            break;
          case 'ends_with':
            if (!String(docValue || '').toLowerCase().endsWith(String(value || '').toLowerCase())) return false;
            break;
        }
      }
      return true;
    });
  },
  async goToPage(page) {
    if (page < 1 || page > this.totalPages || page === this.currentPage) return;
    await this.loadDataFromPouchDB(page);
  },
  async nextPage() {
    if (this.currentPage < this.totalPages) {
      await this.goToPage(this.currentPage + 1);
    }
  },
  async prevPage() {
    if (this.currentPage > 1) {
      await this.goToPage(this.currentPage - 1);
    }
  },
  async performSearch() {
    // Reset to first page when searching
    await this.loadDataFromPouchDB(1);
  },
  clearSearch() {
    this.searchQuery = '';
    this.loadDataFromPouchDB(1);
  },
  async exportToCSV() {
    if (!card.config.dataSource) return;

    try {
      // Get all data without pagination for export
      const formId = card.config.dataSource;
      await initializePouchDB(formId);
      const pouchDB = new PouchDB(formId);

      // Build selector for export (same as current filters but no pagination)
      const selector = this.buildMangoSelector();

      let allData = [];
      try {
        const result = await pouchDB.find({
          selector: selector
        });
        allData = result.docs.filter(doc => !doc._id.startsWith('_design/'));
      } catch (findError) {
        // Fallback to allDocs if Mango query fails
        const result = await pouchDB.allDocs({ include_docs: true });
        const allDocs = result.rows.map(row => row.doc).filter(doc => !doc._id.startsWith('_design/'));
        allData = this.applyFiltersInMemory(allDocs);
      }

      if (allData.length === 0) {
        alert('No data to export');
        return;
      }

      // Get visible columns for export
      const visibleColumns = (card.config.columns || []).filter(col => col.visible);

      if (visibleColumns.length === 0) {
        alert('No visible columns to export');
        return;
      }

      // Create CSV content
      const headers = visibleColumns.map(col => col.label || col.key).join(';');
      const rows = allData.map(row => {
        return visibleColumns.map(col => {
          const value = row[col.key];
          if (value === null || value === undefined) return '';
          if (Array.isArray(value)) return '\'' + value.join(', ') + '\'';
          return '\'' + String(value).replace(/'/g, '\'\'') + '\'';
        }).join(';');
      });

      const csvContent = [headers, ...rows].join('\n');

      // Create and download file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', card.config.dataSource + '_export_' + new Date().toISOString().split('T')[0] + '.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

    } catch (error) {
      console.error('Export failed:', error);
      alert('Export failed: ' + error.message);
    }
  },
  async initializePouchDB() {
      if (!this.card.config.localDBName || !this.card.config.dataSource) return;

      try {
        // Initialize PouchDB
        this.localDB = new PouchDB(this.card.config.localDBName);

        // Check if this is a drafts data source
        const isDrafts = this.card.config.dataSource.endsWith('_drafts');
        const formId = isDrafts ? this.card.config.dataSource.replace('_drafts', '') : this.card.config.dataSource;

        let response;
        if (isDrafts) {
          // Fetch drafts data
          response = await fetch(`/pc-analytics-jaffar/forms/api/pouchdb/init-drafts/${formId}`, {
            method: 'POST'
          });
        } else {
          // Fetch submitted data
          response = await fetch(`/pc-analytics-jaffar/forms/api/pouchdb/init/${formId}`, {
            method: 'POST'
          });
        }

        if (!response.ok) {
          throw new Error(`Failed to fetch data: ${response.statusText}`);
        }

        const data = await response.json();
        const chunks = data.chunks || [];

        // Store chunks in PouchDB
        for (let i = 0; i < chunks.length; i++) {
          const chunk = chunks[i];
          if (chunk && chunk.length > 0) {
            await this.localDB.put({
              _id: `chunk_${i}`,
              data: chunk
            });
          }
        }

        console.log(`Initialized PouchDB with ${chunks.length} chunks`);
      } catch (error) {
        console.error('Error initializing PouchDB:', error);
      }
    },
    async loadData(page = 1) {
      if (!this.card.config.dataSource) return;

      this.loading = true;
      this.error = null;

      try {
        if (this.card.config.saveToLocalDB && this.localDB) {
          await this.loadDataFromPouchDB(page);
        } else {
          const isDrafts = this.card.config.dataSource.endsWith('_drafts');
          const formId = isDrafts ? this.card.config.dataSource.replace('_drafts', '') : this.card.config.dataSource;
          const pageSize = this.card.config.pageSize || 25;

          let response;
          if (isDrafts) {
            response = await fetch(
              `/pc-analytics-jaffar/forms/api/draft-responses/${formId}?page=${page}&page_size=${pageSize}`
            );
          } else {
            response = await fetch(
              `/pc-analytics-jaffar/forms/api/submitted-responses/${formId}?page=${page}&page_size=${pageSize}`
            );
          }

          if (!response.ok) {
            throw new Error(`Failed to fetch data: ${response.statusText}`);
          }

          const data = await response.json();
          this.rawData = data.issues || [];
          this.totalRecords = data.total || 0;
          this.currentPage = data.page || 1;
          this.totalPages = data.total_pages || 1;
        }

        this.applyFilters();
      } catch (error) {
        console.error('Error loading data:', error);
        this.error = 'Failed to load data';
        this.rawData = [];
      } finally {
        this.loading = false;
      }
    }
}
```

I have found the mistake. There's an extra `}` at the end of line 431 in the original code.
I will remove async initializePouchDB() and async loadData() function, and replace the exportToCSV() function with the new one.
Then I will add `}` and `x-init="loadDataFromPouchDB()"` to the end of the Alpine.js data object.

```html
<div class="bg-gray-800 p-4 rounded-lg h-full" x-data="{
  previewData: [], 
  loading: false,
  currentPage: 1,
  totalPages: 1,
  totalCount: 0,
  searchQuery: '',
  async loadDataFromPouchDB(page = 1) {
    if (!card.config.dataSource) return;

    this.loading = true;
    const formId = card.config.dataSource;

    try {
      await initializePouchDB(formId);
      const pouchDB = new PouchDB(formId);

      // Use configured page size, default to 25 if not set
      const pageSize = parseInt(card.config.pageSize) || 25;
      const skip = (page - 1) * pageSize;

      // Build Mango query selector with predefined filters
      const selector = this.buildMangoSelector();

      // Get filtered data using Mango query
      let allData = [];
      try {
        const result = await pouchDB.find({
          selector: selector
        });
        allData = result.docs.filter(doc => !doc._id.startsWith('_design/'));
      } catch (findError) {
        // Fallback to allDocs if Mango query fails
        const result = await pouchDB.allDocs({ include_docs: true });
        const allDocs = result.rows.map(row => row.doc).filter(doc => !doc._id.startsWith('_design/'));
        // Apply filters in memory if Mango query failed
        allData = this.applyFiltersInMemory(allDocs);
      }

      // Set total count and pages
      this.totalCount = allData.length;
      this.totalPages = Math.ceil(this.totalCount / pageSize);
      this.currentPage = page;

      // Apply pagination in memory
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      this.previewData = allData.slice(startIndex, endIndex);

      console.log(`Displaying page ${page}/${this.totalPages}, showing ${this.previewData.length} of ${this.totalCount} documents`);

    } catch (error) {
      console.error('Failed to load preview data for form', formId, ':', error);
      this.previewData = [];
    } finally {
      this.loading = false;
    }
  },
  buildMangoSelector() {
    // Start with base selector to exclude design documents
    const selector = {
      '_id': { '$gt': null }
    };

    // Add search query if provided
    if (this.searchQuery && this.searchQuery.trim()) {
      const searchTerm = this.searchQuery.trim();
      const searchableColumns = (card.config.columns || []).filter(col => col.visible && col.key);

      if (searchableColumns.length > 0) {
        // Create OR condition for searching across all visible columns
        const searchConditions = searchableColumns.map(column => ({
          [column.key]: { '$regex': new RegExp(searchTerm, 'i') }
        }));

        selector['$or'] = searchConditions;
      }
    }

    // Add predefined filters from column configuration
    const columns = card.config.columns || [];

    for (const column of columns) {
      if (!column.enablePredefinedFilter) continue;

      const fieldName = column.key;
      const operator = column.filterOperator || 'equals';
      let value = column.filterValue;

      // For multi-select fields, use filterValues array
      if (column.filterValues && Array.isArray(column.filterValues) && column.filterValues.length > 0) {
        value = column.filterValues;
      }

      // Skip if no value provided (except for exists/not_exists/empty/not_empty)
      if (!value && !['exists', 'not_exists', 'empty', 'not_empty'].includes(operator)) continue;

      switch (operator) {
        case 'equals':
          selector[fieldName] = value;
          break;
        case 'not_equals':
          selector[fieldName] = { '$ne': value };
          break;
        case 'contains':
          selector[fieldName] = { '$regex': new RegExp(value, 'i') };
          break;
        case 'not_contains':
          selector[fieldName] = { '$not': { '$regex': new RegExp(value, 'i') } };
          break;
        case 'greater_than':
          selector[fieldName] = { '$gt': parseFloat(value) || value };
          break;
        case 'less_than':
          selector[fieldName] = { '$lt': parseFloat(value) || value };
          break;
        case 'greater_equal':
          selector[fieldName] = { '$gte': parseFloat(value) || value };
          break;
        case 'less_equal':
          selector[fieldName] = { '$lte': parseFloat(value) || value };
          break;
        case 'in':
          const inValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
          selector[fieldName] = { '$in': inValues };
          break;
        case 'not_in':
          const notInValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
          selector[fieldName] = { '$nin': notInValues };
          break;
        case 'exists':
          selector[fieldName] = { '$exists': true };
          break;
        case 'not_exists':
          selector[fieldName] = { '$exists': false };
          break;
        case 'empty':
          selector[fieldName] = { '$in': [null, '', undefined] };
          break;
        case 'not_empty':
          selector[fieldName] = { '$nin': [null, '', undefined] };
          break;
        case 'starts_with':
          selector[fieldName] = { '$regex': new RegExp(`^${value}`, 'i') };
          break;
        case 'ends_with':
          selector[fieldName] = { '$regex': new RegExp(`${value}$`, 'i') };
          break;
      }
    }

    return selector;
  },
  applyFiltersInMemory(docs) {
    // Fallback method to apply filters in memory when Mango queries fail
    let filteredDocs = docs;

    // Apply search filter first
    if (this.searchQuery && this.searchQuery.trim()) {
      const searchTerm = this.searchQuery.trim().toLowerCase();
      const searchableColumns = (card.config.columns || []).filter(col => col.visible && col.key);

      filteredDocs = filteredDocs.filter(doc => {
        return searchableColumns.some(column => {
          const value = doc[column.key];
          if (value === null || value === undefined) return false;
          return String(value).toLowerCase().includes(searchTerm);
        });
      });
    }

    // Apply predefined filters
    const columns = card.config.columns || [];

    return filteredDocs.filter(doc => {
      for (const column of columns) {
        if (!column.enablePredefinedFilter) continue;

        const fieldName = column.key;
        const operator = column.filterOperator || 'equals';
        let value = column.filterValue;

        // For multi-select fields, use filterValues array
        if (column.filterValues && Array.isArray(column.filterValues) && column.filterValues.length > 0) {
          value = column.filterValues;
        }

        // Skip if no value provided (except for exists/not_exists/empty/not_empty)
        if (!value && !['exists', 'not_exists', 'empty', 'not_empty'].includes(operator)) continue;

        const docValue = doc[fieldName];

        switch (operator) {
          case 'equals':
            if (docValue != value) return false;
            break;
          case 'not_equals':
            if (docValue == value) return false;
            break;
          case 'contains':
            if (!String(docValue || '').toLowerCase().includes(String(value || '').toLowerCase())) return false;
            break;
          case 'not_contains':
            if (String(docValue || '').toLowerCase().includes(String(value || '').toLowerCase())) return false;
            break;
          case 'greater_than':
            if (!(parseFloat(docValue) > parseFloat(value))) return false;
            break;
          case 'less_than':
            if (!(parseFloat(docValue) < parseFloat(value))) return false;
            break;
          case 'greater_equal':
            if (!(parseFloat(docValue) >= parseFloat(value))) return false;
            break;
          case 'less_equal':
            if (!(parseFloat(docValue) <= parseFloat(value))) return false;
            break;
          case 'in':
            const inValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
            if (!inValues.includes(String(docValue))) return false;
            break;
          case 'not_in':
            const notInValues = Array.isArray(value) ? value : value.split(',').map(v => v.trim());
            if (notInValues.includes(String(docValue))) return false;
            break;
          case 'exists':
            if (docValue === null || docValue === undefined) return false;
            break;
          case 'not_exists':
            if (docValue !== null && docValue !== undefined) return false;
            break;
          case 'empty':
            if (docValue !== null && docValue !== undefined && docValue !== '') return false;
            break;
          case 'not_empty':
            if (docValue === null || docValue === undefined || docValue === '') return false;
            break;
          case 'starts_with':
            if (!String(docValue || '').toLowerCase().startsWith(String(value || '').toLowerCase())) return false;
            break;
          case 'ends_with':
            if (!String(docValue || '').toLowerCase().endsWith(String(value || '').toLowerCase())) return false;
            break;
        }
      }
      return true;
    });
  },
  async goToPage(page) {
    if (page < 1 || page > this.totalPages || page === this.currentPage) return;
    await this.loadDataFromPouchDB(page);
  },
  async nextPage() {
    if (this.currentPage < this.totalPages) {
      await this.goToPage(this.currentPage + 1);
    }
  },
  async prevPage() {
    if (this.currentPage > 1) {
      await this.goToPage(this.currentPage - 1);
    }
  },
  async performSearch() {
    // Reset to first page when searching
    await this.loadDataFromPouchDB(1);
  },
  clearSearch() {
    this.searchQuery = '';
    this.loadDataFromPouchDB(1);
  },
  async exportToCSV() {
    if (!card.config.dataSource) return;

    try {
      // Get all data without pagination for export
      const formId = card.config.dataSource;
      await initializePouchDB(formId);
      const pouchDB = new PouchDB(formId);

      // Build selector for export (same as current filters but no pagination)
      const selector = this.buildMangoSelector();

      let allData = [];
      try {
        const result = await pouchDB.find({
          selector: selector
        });
        allData = result.docs.filter(doc => !doc._id.startsWith('_design/'));
      } catch (findError) {
        // Fallback to allDocs if Mango query fails
        const result = await pouchDB.allDocs({ include_docs: true });
        const allDocs = result.rows.map(row => row.doc).filter(doc => !doc._id.startsWith('_design/'));
        allData = this.applyFiltersInMemory(allDocs);
      }

      if (allData.length === 0) {
        alert('No data to export');
        return;
      }

      // Get visible columns for export
      const visibleColumns = (card.config.columns || []).filter(col => col.visible);

      if (visibleColumns.length === 0) {
        alert('No visible columns to export');
        return;
      }

      // Create CSV content
      const headers = visibleColumns.map(col => col.label || col.key).join(';');
      const rows = allData.map(row => {
        return visibleColumns.map(col => {
          const value = row[col.key];
          if (value === null || value === undefined) return '';
          if (Array.isArray(value)) return '\"' + value.join(', ') + '\"';
          return '\"' + String(value).replace(/\"/g, '\"\"') + '\"';
        }).join(';');
      });

      const csvContent = [headers, ...rows].join('\n');

      // Create and download file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', card.config.dataSource + '_export_' + new Date().toISOString().split('T')[0] + '.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

    } catch (error) {
      console.error('Export failed:', error);
      alert('Export failed: ' + error.message);
    }
  }
}" x-init="loadDataFromPouchDB()">

  <!-- Data Source Info -->
  <div x-show="card.config.dataSource" class="mb-2 flex justify-between items-center">
    <div class="text-xs text-gray-400 flex items-center gap-2">
      <span>Source: <span x-text="card.config.dataSource"></span></span>
      <span x-show="(card.config.columns || []).filter(col => col.enablePredefinedFilter).length > 0" 
            class="bg-blue-600 text-white px-2 py-1 rounded text-xs flex items-center gap-1"
            :title="`${(card.config.columns || []).filter(col => col.enablePredefinedFilter).length} active filters`">
        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.707A1 1 0 013 7V4z"></path>
        </svg>
        <span x-text="(card.config.columns || []).filter(col => col.enablePredefinedFilter).length"></span>
      </span>
    </div>
    <button @click="
      const formId = card.config.dataSource; 
      console.log('Syncing form:', formId); 
      loading = true;
      syncPouchDB(formId).then(() => {
        console.log('Sync completed, reloading data...');
        return loadDataFromPouchDB(1);
      }).catch(error => {
        console.error('Sync failed:', error);
        loading = false;
      });
    " 
            class="bg-blue-600 hover:bg-blue-500 text-white px-2 py-1 rounded text-xs flex items-center gap-1"
            title="Synchronize data"
            :disabled="loading">
      <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0A9.953 9.953 0 0112 21c-4.478 0-8.268-2.943-9.543-7a10.025 10.025 0 014.132-5.411"></path>
      </svg>
      Sync
    </button>
  </div>

  <!-- Search Bar -->
  <div x-show="card.config.dataSource" class="mb-4">
    <div class="flex gap-2">
      <input type="text" 
             x-model="searchQuery" 
             @keyup.enter="performSearch()"
             placeholder="Search..."
             class="flex-1 bg-gray-700 text-white p-2 rounded border border-gray-600">
      <button @click="performSearch()" 
              class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded">
        Search
      </button>
      <button @click="clearSearch()" 
              class="bg-gray-600 hover:bg-gray-500 text-white px-4 py-2 rounded">
        Clear
      </button>
    </div>
  </div>

  <!-- Export Button -->
  <div x-show="card.config.dataSource && previewData.length > 0" class="mb-4">
    <button @click="exportToCSV()" 
            class="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded flex items-center gap-2">
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
      </svg>
      Export CSV
    </button>
  </div>

  <!-- Loading Indicator -->
  <div x-show="loading" class="flex justify-center items-center p-8">
    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
  </div>

  <!-- Data Table -->
  <div x-show="!loading && card.config.dataSource" class="overflow-x-auto">
    <!-- No Data Message -->
    <div x-show="previewData.length === 0" class="text-center py-8 text-gray-400">
      No data available
    </div>

    <!-- Table -->
    <table x-show="previewData.length > 0" class="min-w-full bg-gray-700 rounded-lg overflow-hidden">
      <thead class="bg-gray-600">
        <tr>
          <template x-for="column in (card.config.columns || []).filter(col => col.visible)">
            <th class="px-4 py-2 text-left text-white font-medium" x-text="column.label || column.key"></th>
          </template>
        </tr>
      </thead>
      <tbody>
        <template x-for="(row, index) in previewData">
          <tr class="border-t border-gray-600 hover:bg-gray-600">
            <template x-for="column in (card.config.columns || []).filter(col => col.visible)">
              <td class="px-4 py-2 text-gray-300">
                <template x-if="column.isHtml">
                  <div x-html="row[column.key] || ''"></div>
                </template>
                <template x-if="!column.isHtml">
                  <span x-text="row[column.key] || ''"></span>
                </template>
              </td>
            </template>
          </tr>
        </template>
      </tbody>
    </table>

    <!-- Pagination -->
    <div x-show="previewData.length > 0" class="mt-4 flex justify-between items-center text-sm text-gray-400">
      <div>
        <span>Showing page </span>
        <span x-text="currentPage"></span>
        <span> of </span>
        <span x-text="totalPages"></span>
        <span> (</span>
        <span x-text="totalCount"></span>
        <span> total records)</span>
      </div>
      <div class="flex gap-2">
        <button @click="prevPage()" 
                :disabled="currentPage <= 1"
                :class="currentPage <= 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-600'"
                class="bg-gray-700 text-white px-3 py-1 rounded">
          Previous
        </button>
        <button @click="nextPage()" 
                :disabled="currentPage >= totalPages"
                :class="currentPage >= totalPages ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-600'"
                class="bg-gray-700 text-white px-3 py-1 rounded">
          Next
        </button>
      </div>
    </div>
  </div>

  <!-- No Data Source Message -->
  <div x-show="!card.config.dataSource" class="text-center py-8 text-gray-400">
    <p>No data source configured</p>
    <p class="text-sm mt-2">Configure a data source in the card settings to display data</p>
  </div>
</div>